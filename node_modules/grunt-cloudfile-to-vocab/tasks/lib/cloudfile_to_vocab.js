'use strict';

module.exports = function () {

    var replaceCharacters = [{
            from: '&#44;',  // fix misinterpreting commas
            to:   ','
        }, {
            from: '£',      // html encode characters
            to:   '&pound;'
        }, {
            from: '\\"',
            to:   '&quot;'
        }, {
            from: '“',
            to:   '&quot;'
        }, {
            from: '”',
            to:   '&quot;'
        }, {
            from: '\\n',
            to:   '<br>'
        }, {
            from: '’',      // MS-Word-style apostrophes
            to:   '\''
        }];

    var http    = require('http'),
        csv     = require('csv'),
        fs      = require('fs'),
        request = require('request'),
        gruntTextReplace = require('grunt-text-replace/lib/grunt-text-replace'),
        _       = require('lodash');

    var cloudfileToVocab = {

        data: '',
        done: null,
        vocabsFinishedWriting: false,

        process: function (opts, done) {
            if (opts.google_spreadsheet_id) {
                this.validateInputsForGoogle(opts, done);
                this.processGoogleSpreadsheet(opts);
            }
            else {
                this.validateInputsForCsv(opts, done);
                this.processCsv(opts);
            }
            this.waitUntilVocabsAreDoneThenMergeJson(done);
        },

        waitUntilVocabsAreDoneThenMergeJson: function (done) {
            if (!this.vocabsFinishedWriting) {
                setTimeout(function () {
                    this.waitUntilVocabsAreDoneThenMergeJson(done);
                }.bind(this), 100);
            } else {
                this.recurseFiles(this.outputDirectory, function (err, filepaths) {
                    if (err) {
                        this.throwError('Could not walk through output directory.');
                    }
                    this.mergeJsonFiles(filepaths, done);
                }.bind(this), this);
            }
        },

        /**
         * Returns an array of all the filepaths in a given directory, e.g.
         * ['/test/sheet1/english.json', 'test/sheet2/english.json', 'test/sheet1/mundo.json']
         *
         * Shamelessly copied from http://stackoverflow.com/a/5827895
         *
         * Node doesn't have a built-in recursive walk, and Node-module implementations
         * of walk behaviour are surprisingly hit-and-miss.
         * 
         * @param  {String}   dir    Directory to walk.
         * @param  {Function} done   Callback to execute once list of files is generated.
         * @param  {Object}   scope  Allows us to pass `this` to the function, as the function needs to call itself.
         * @return {Array{{String}}} The array of filepaths found.
         */
        recurseFiles: function (dir, done, scope) {
            var results = [];
            fs.readdir(dir, function(err, list) {
                if (err) {
                    scope.throwError(err);
                }
                var pending = list.length;
                if (!pending) {
                    return done(null, results);
                }
                list.forEach(function(file) {
                    file = dir + '/' + file;
                    fs.stat(file, function(err, stat) {
                        if (stat && stat.isDirectory()) {
                            scope.recurseFiles(file, function(err, res) {
                                results = results.concat(res);
                                if (!--pending) {
                                    done(null, results);
                                }
                            }, scope);
                        } else {
                            results.push(file);
                            if (!--pending) {
                                done(null, results);
                            }
                        }
                    });
                });
            });
        },

        mergeJsonFiles: function (filepaths, done) {
            this.getFromFilePaths('services', filepaths).forEach(function (service) {
                var jsons            = this.getJsonFilesFor(service, filepaths),
                    combinedJson     = this.combineJsons(jsons),
                    combinedJsonFile = this.outputDirectory + '/' + service;

                fs.writeFileSync(combinedJsonFile, JSON.stringify(combinedJson, null, 4));
                console.log('Created ' + combinedJsonFile);
            }.bind(this));
            
            // required callback as grunt tasks are async.  If null, code in the scope above will not wait
            this.done = done || null;
            this.executeNextGruntTask();
        },

        getFromFilePaths: function (get, filepaths) {
            var subdirectories = [],
                services = [];

            filepaths.forEach(function (filepath) {
                var filename = filepath.replace(/^.*[\\\/]/, ''),
                    subdir   = filepath.substring(0, filepath.lastIndexOf('/'));

                if (subdirectories.indexOf(subdir) === -1) {
                    subdirectories.push(subdir);
                }
                if (services.indexOf(filename) === -1) {
                    services.push(filename);
                }
            });

            if (get === 'services') {
                return services;
            }
            else {
                return subdirectories;
            }
        },

        getJsonFilesFor: function (service, filepaths) {
            var subdirectories = this.getFromFilePaths('subdirectories', filepaths),
                jsons          = [],
                stringyJson;

            subdirectories.forEach(function (directory) {
                stringyJson = fs.readFileSync(directory + '/' + service, {'encoding': 'utf8'});
                jsons.push(JSON.parse(stringyJson));
            });

            return jsons;
        },

        combineJsons: function (jsons) {
            var combinedJson = {};

            jsons.forEach(function (json) {
                _.merge(combinedJson, json);
            });
            
            return combinedJson;
        },

        validateInputsForGoogle: function (opts, done) {
            this.validateInputsGenerally(opts, done);

            if (!opts.username || !opts.password) {
                this.throwError('Google spreadsheets require username and password values in the options');
            }
            else if (!opts.worksheets || opts.worksheets.length === 0) {
                this.throwError('You must specify at least one worksheet ID to process');
            }
        },

        validateInputsForCsv: function (opts, done) {
            this.validateInputsGenerally(opts, done);
            if (!opts.document_url) {
                this.throwError('Please provide a document_url in the options');
            }
            if (opts.document_url.match(/https?:\/\/(.*google).*\//)) {
                this.throwError('To access Google spreadsheets provide a google_spreadsheet_id property in the options instead.');
            }
        },

        validateInputsGenerally: function (opts, done) {
            if (!opts) {
                this.throwError('Please provide options to process');
            }
            else if (!opts.whitelisted_services) {
                this.throwError('Please provide a whitelist of acceptable language names (as the whitelisted_services parameter).');
            }

            this.whitelisted = opts.whitelisted_services;
            this.outputDirectory = opts.output_directory || '';
        },

        processCsv: function (opts) {
            this.getFile(opts.document_url);
        },

        processGoogleSpreadsheet: function (opts) {
            var id          = opts.google_spreadsheet_id;
            var username    = opts.username;
            var password    = opts.password;
            this.worksheets = opts.worksheets;
            this.setupGoogleSpreadsheetService(opts);

            this.data = [];
            this.forEachWorksheet(function (worksheet) {
                this.getFileFromGoogle(id, worksheet, username, password);
            }.bind(this));

            this.tryToMakeVocabs();
        },

        tryToMakeVocabs: function () {
            if (this.data.length !== this.worksheets.length) {
                setTimeout(this.tryToMakeVocabs.bind(this), 150);
            } else {
                this.makeVocabs();
            }
        },

        setupGoogleSpreadsheetService: function (opts) {
            this.googleSpreadsheetService = opts.fake_google_spreadsheet_service || require('edit-google-spreadsheet');
        },

        getFile: function (url) {
            var that = this;
            request(url, function (error, response, body) {
                that.convertCsvToArray(body, function (arr) {
                    that.data = arr;
                    that.makeVocabs();
                });
            });
        },

        getFileFromGoogle: function (id, worksheet, username, password) {
            var that = this;
            this.googleSpreadsheetService.create({
                debug: true,
                username: username,
                password: password,
                spreadsheetName: 'node-edit-spreadsheet',
                worksheetName: worksheet,
                spreadsheetId: id,
                callback: function (err, spreadsheet) {
                    if(err) {
                        throw err;
                    }
                    //receive all cells
                    spreadsheet.receive(function(err, rows, info) {
                        if(err) {
                            throw err;
                        }
                        that.data.push(that.convertGoogleSpreadSheetDataToArray(rows));
                    });
                }
            });
        },

        /*
         * Take the 2 dimensional array - this.data - and convert it into json files.
         * Array is ordered by rows, each row has an array of columns.
         * Each generated json file needs to take the correct item from each row
         */
        makeVocabs: function () {
            this.makeOutputDirectory(this.outputDirectory);

            if (this.numberOfWorksheets() > 1) {
                this.forEachWorksheet(function (worksheet) {
                    this.makeOutputDirectory(this.outputDirectory + '/' + worksheet);
                }.bind(this));
            }

            var cloudfileToVocab = this;
            this.forEachWorksheet(function (worksheet) {
                cloudfileToVocab.forEachLanguage(function (languageName, translationPositionInArray) { // loops through each row
                    if (cloudfileToVocab.whitelisted.indexOf(languageName) < 0) {
                        cloudfileToVocab.throwError(languageName + ' is not a valid language name! Check your column headers!');
                    }
                    var vocabFileContents = {};
                    cloudfileToVocab.forEachWordToBeTranslated(function (wordTranslations) {
                        cloudfileToVocab.translateWord(vocabFileContents, wordTranslations, translationPositionInArray);
                    });
                    cloudfileToVocab.makeVocabFile(languageName.trim(), JSON.stringify(vocabFileContents, null, 4));
                });
            });
            this.vocabsFinishedWriting = true;
        },

        translateWord: function (vocabFileContents, wordTranslations, translationPositionInArray) {
            var label          = wordTranslations[0].trim(), // first item in the array is the label (i.e. the value that is translated in each language)
                translatedWord = (wordTranslations[translationPositionInArray] || "").trim();

            if (label !== 'ignore') {
                vocabFileContents[label] = translatedWord;
            }
        },

        executeNextGruntTask: function () {
            if (this.done) {
                this.prepareTextForBrowser(this.outputDirectory);
                this.done();
            }
        },

        prepareTextForBrowser: function (outputDirectory) {
            gruntTextReplace.replaceFileMultiple({
                src: ['./' + outputDirectory + '/*.json'],
                overwrite: true,
                replacements: replaceCharacters
            });
        },

        makeVocabFile: function(fileName, contents) {
            var fileToWriteTo;

            if (this.numberOfWorksheets() > 1) {
                fileToWriteTo = './' + this.outputDirectory + '/' + this.worksheets[this.dataElementIndex] + '/' + fileName + '.json';
            }
            else {
                fileToWriteTo = './' + this.outputDirectory + '/' + fileName + '.json';
            }

            fs.writeFileSync(fileToWriteTo, contents);
        },

        defineWorksheetsIfNotDefined: function () {
            if (!this.worksheets) {
                this.worksheets = ['csv_file'];
            }
        },

        numberOfWorksheets: function () {
            this.defineWorksheetsIfNotDefined();
            return this.worksheets.length;
        },

        forEachWorksheet: function (callback) {
            this.defineWorksheetsIfNotDefined();
            this.dataElementIndex = -1;
            do {
                this.dataElementIndex++;
                callback(this.worksheets[this.dataElementIndex]);
            } while(this.dataElementIndex < this.numberOfWorksheets()-1);
        },

        forEachWordToBeTranslated: function(callback) {
            var dataMinusLanguageNames = this.getDataMinusLanguageNames();
            dataMinusLanguageNames.forEach(callback);
        },

        forEachLanguage: function (callback) {
            var languages = this.getLanguages();
            languages.forEach(function(languageName, languagePosition) {
                languagePosition++; // true column position is +1 as the first column is the word label
                callback(languageName, languagePosition);
            });
        },

        getLanguages: function () {
            if (this.wasACsvAndNotAGoogleSpreadsheet()) {
                return this.data[this.dataElementIndex].slice(1); // used for getting language from csv
            }
            else {
                return this.data[this.dataElementIndex][0].slice(1); // e.g. creates [english', 'mundo'] from ['', 'english', 'mundo']
            }
        },

        getDataMinusLanguageNames: function () {
            if (this.wasACsvAndNotAGoogleSpreadsheet()) {
                return this.data.slice(1);
            }
            else {
                return this.data[this.dataElementIndex].slice(1);
            }
        },

        wasACsvAndNotAGoogleSpreadsheet: function () {
            // csv does not support multiple worksheets, so does not contain a nested array
            return typeof this.data[this.dataElementIndex][0] === 'string';
        },

        makeOutputDirectory: function (outputDirectory) {
            if (outputDirectory !== '') {
                var mkdirp = require('mkdirp');
                mkdirp(outputDirectory);
            }
        },

        convertCsvToArray: function (csvFile, callback) {
            csv().from.string(csvFile, {trim: true}).to.array(callback);
        },

        convertGoogleSpreadSheetDataToArray: function (json) {
            var csvArray              = [],
                numberOfItemsRequired = this.getHighestNamedKeyValue(json['1']);
            for (var item in json) {
                if (json.hasOwnProperty(item)) {
                    csvArray.push(this.convertJsonToArray(json[item], numberOfItemsRequired));
                }
            }
            return csvArray;
        },

        convertJsonToArray: function (json, numberOfItemsRequired) {
            var csvRow = [];
            for (var i = 1; i <= numberOfItemsRequired; i++) {
                var itemValue = '';
                if (json.hasOwnProperty(i.toString())) {
                    itemValue = json[i.toString()].toString().replace(",", "&#44;");
                }
                csvRow[i-1] = itemValue;
            }
            return csvRow;
        },

        getHighestNamedKeyValue: function (assocArray) {
            return Math.max.apply(Math.max,_.keys(assocArray));
        },

        /*
         * ERROR HANDLING
         */

        consoleWarnFacade: null,
        warningMessage: function (message) {
            if (this.consoleWarnFacade) {
                this.consoleWarnFacade(message);
            }
            else {
                console.warn(message);
            }
        },

        throwError: function (errMsg) {
            this.warningMessage(errMsg);
            throw new Error(errMsg);
        },

    };

    return cloudfileToVocab;

};